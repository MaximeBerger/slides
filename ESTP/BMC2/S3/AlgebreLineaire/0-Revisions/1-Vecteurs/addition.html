<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Addition et multiplication de vecteurs (2D)</title>
  <style>
    html, body { height: 100%; margin: 0; background: transparent; }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      background: transparent;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }
    .page { 
      display: flex; 
      flex-direction: column;
      align-items: center; 
      gap: 20px; 
      padding: 16px; 
      background: transparent; 
    }
    .title-container { text-align: center; margin-bottom: 8px; }
    .title-container h1 {
      font-size: 28px;
      font-weight: 700;
      color: #1f2937;
      margin: 0;
      letter-spacing: -0.5px;
    }
    .subtitle { color:#4b5563; margin: 4px 0 0; font-size:14px; }
    .content { display: flex; align-items: flex-start; gap: 20px; }

    /* Zone dessin p5.js */
    #container {
      position: relative;
      width: 800px;   /* canvas = 800x600 comme demandé */
      height: 626px;  /* 600 + marge interne */
      overflow: hidden;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: transparent;
      box-shadow: 0 6px 18px rgba(0,0,0,0.08);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Panneau latéral séparé */
    #panel {
      width: 300px;
      height: 600px;
      padding: 12px;
      border-radius: 10px;
      background: transparent;
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      overflow: auto;
    }

    /* Petits styles d’UI */
    .section { margin-bottom: 14px; }
    .section h3 { margin: 8px 0 6px; font-size: 14px; color:#111827; }
    .row { display:flex; align-items:center; gap:8px; margin:6px 0; }
    .row label { font-size: 13px; color:#374151; min-width: 90px; }
    .row input[type="range"] { width: 100%; }
    .value-pill {
      padding: 2px 8px; border-radius: 999px; background: #f3f4f6; font-size:12px; color:#111827; border:1px solid #e5e7eb;
      min-width: 48px; text-align: right;
    }
    .toggle { display:flex; gap:8px; flex-wrap: wrap; }
    .toggle label { display:flex; align-items:center; gap:6px; font-size: 13px; color:#374151; }
    .btns { display:flex; gap:8px; flex-wrap: wrap; }
    button {
      appearance: none; border:1px solid #e5e7eb; background:#fff; color:#111827; border-radius:8px; padding:6px 10px;
      font-size:13px; cursor:pointer; box-shadow: 0 1px 2px rgba(0,0,0,0.04);
    }
    button:hover { background:#f9fafb; }
    .legend { display:flex; gap:10px; flex-wrap:wrap; font-size:12px; color:#374151; }
    .legend .dot { width:10px; height:10px; border-radius:50%; display:inline-block; }
    .k-u { background:#2563eb; }       /* u (bleu) */
    .k-v { background:#ea580c; }       /* v (orange) */
    .k-au { background:#60a5fa; }      /* αu (bleu clair) */
    .k-bv { background:#f59e0b; }      /* βv (orange clair) */
    .k-sum { background:#10b981; }     /* r = αu+βv (vert) */

    .help { font-size:12px; color:#6b7280; line-height:1.4; background:#f9fafb; border:1px solid #e5e7eb; padding:8px; border-radius:8px; }
    .math { font-size: 14px; line-height: 1.5; color:#111827; }
    .small { font-size: 12px; color:#6b7280; }

    /* curseurs de drag */
    .cursor-help { cursor: help; }
  </style>

  <!-- MathJax (config puis script) -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$']], displayMath: [['$$', '$$']] },
      svg: { fontCache: 'global' }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <!-- p5.js -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>
</head>
<body>
  <div class="page">
    <div class="title-container">
      <h1>Addition de vecteurs & multiplication par un scalaire (2D)</h1>
      <p class="subtitle">Glissez les extrémités de <strong>u</strong> et <strong>v</strong> • Réglez $\alpha$ et $\beta$ • Visualisez $\alpha \mathbf u + \beta \mathbf v$</p>
    </div>

    <div class="content">
      <div id="container" title="Glissez les points bleus/oranges pour déplacer u et v.">
        <!-- Le canvas p5 sera inséré ici -->
      </div>

      <div id="panel">
        <div class="section">
          <div class="legend">
            <span><span class="dot k-u"></span> $\mathbf u$</span>
            <span><span class="dot k-v"></span> $\mathbf v$</span>
            <span><span class="dot k-au"></span> $\alpha \mathbf u$</span>
            <span><span class="dot k-bv"></span> $\beta \mathbf v$</span>
            <span><span class="dot k-sum"></span> $\mathbf r = \alpha \mathbf u + \beta \mathbf v$</span>
          </div>
        </div>

        <div class="section">
          <h3>Scalaires</h3>
          <div class="row">
            <label for="alpha">$\alpha$</label>
            <input id="alpha" type="range" min="-2" max="2" step="0.01" value="1">
            <span class="value-pill" id="alphaVal">1.00</span>
          </div>
          <div class="row" id="betaRow">
            <label for="beta">$\beta$</label>
            <input id="beta" type="range" min="-2" max="2" step="0.01" value="1">
            <span class="value-pill" id="betaVal">1.00</span>
          </div>
          <div class="row">
            <label style="min-width:unset;">
              <input type="checkbox" id="linkScalars">
              Lier $\alpha = \beta = k$
            </label>
            <span class="small">Pratique pour $k(\mathbf u + \mathbf v)$.</span>
          </div>
        </div>

        <div class="section">
          <h3>Affichages</h3>
          <div class="toggle">
            <label><input type="checkbox" id="showParallelogram" unchecked> Parallélogramme</label>
            <label><input type="checkbox" id="showTriangle" unchecked> Méthode du triangle</label>
            <label><input type="checkbox" id="showSum" unchecked> Afficher $\mathbf r$</label>
            <label><input type="checkbox" id="snapGrid"> Aimantation grille</label>
          </div>
        </div>

        <div class="section btns">
          <button id="resetBtn">Réinitialiser</button>
          <button id="randomBtn">Vecteurs aléatoires</button>
        </div>

        <div class="section help">
          <div>• Les poignées circulaires permettent d’ajuster <strong>u</strong> et <strong>v</strong>.</div>
        </div>

        <div class="section">
          <h3>Formules & valeurs</h3>
          <div id="math" class="math"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------- Paramètres généraux ----------
    const WIDTH = 800, HEIGHT = 600;
    const SCALE = 50; // px par unité
    const AXIS_COLOR = '#9ca3af';
    const GRID_COLOR = '#e5e7eb';
    const MINOR_GRID_COLOR = '#f3f4f6';

    const COL_U = '#2563eb';     // u
    const COL_V = '#ea580c';     // v
    const COL_AU = '#60a5fa';    // αu
    const COL_BV = '#f59e0b';    // βv
    const COL_SUM = '#10b981';   // r

    let origin;                 // centre du canvas en pixels
    let u = { x: 3, y: 2 };     // en unités
    let v = { x: -2, y: 1.5 };

    let alpha = 1.0;
    let beta = 1.0;
    let link = false;

    let dragging = null; // 'u' | 'v' | null
    const HANDLE_R = 9;

    let ui = {};         // références DOM
    let needsTypeset = true;
    let lastTypeset = 0;

    // ---------- Utilitaires ----------
    function toCanvas(p) { // unités -> pixels
      return {
        x: origin.x + p.x * SCALE,
        y: origin.y - p.y * SCALE
      };
    }
    function fromCanvas(px, py) { // pixels -> unités
      return {
        x: (px - origin.x) / SCALE,
        y: (origin.y - py) / SCALE
      };
    }
    function fmt(n) {
      return (Math.abs(n) < 1e-12 ? 0 : n).toFixed(2);
    }
    function dist2(ax, ay, bx, by) {
      let dx = ax - bx, dy = ay - by;
      return dx*dx + dy*dy;
    }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function drawGrid() {
      push();
      strokeWeight(1);
      // fond
      background(255);

      // grille mineure (pas 0.5)
      stroke(MINOR_GRID_COLOR);
      for (let x = origin.x % (SCALE/2); x < WIDTH; x += SCALE/2) line(x, 0, x, HEIGHT);
      for (let y = origin.y % (SCALE/2); y < HEIGHT; y += SCALE/2) line(0, y, WIDTH, y);

      // grille principale (pas 1)
      stroke(GRID_COLOR);
      for (let x = origin.x % SCALE; x < WIDTH; x += SCALE) line(x, 0, x, HEIGHT);
      for (let y = origin.y % SCALE; y < HEIGHT; y += SCALE) line(0, y, WIDTH, y);

      // axes
      stroke(AXIS_COLOR);
      strokeWeight(2);
      line(0, origin.y, WIDTH, origin.y);
      line(origin.x, 0, origin.x, HEIGHT);

      // graduations
      fill('#6b7280');
      noStroke();
      textSize(10);
      textAlign(CENTER, TOP);
      for (let i = -Math.floor(WIDTH/(2*SCALE)); i <= Math.floor(WIDTH/(2*SCALE)); i++) {
        if (i === 0) continue;
        const x = origin.x + i*SCALE;
        text(i, x, origin.y + 2);
      }
      textAlign(LEFT, CENTER);
      for (let j = -Math.floor(HEIGHT/(2*SCALE)); j <= Math.floor(HEIGHT/(2*SCALE)); j++) {
        if (j === 0) continue;
        const y = origin.y - j*SCALE;
        text(j, origin.x + 2, y);
      }
      pop();
    }

    function drawArrow(p0, p1, col, w=3, head=10) {
      push();
      stroke(col);
      strokeWeight(w);
      fill(col);
      line(p0.x, p0.y, p1.x, p1.y);
      // flèche
      const ang = Math.atan2(p1.y - p0.y, p1.x - p0.x);
      const hx = p1.x - Math.cos(ang)*head;
      const hy = p1.y - Math.sin(ang)*head;
      push();
      translate(p1.x, p1.y);
      rotate(ang);
      beginShape();
      vertex(0,0);
      vertex(-head, head*0.6);
      vertex(-head, -head*0.6);
      endShape(CLOSE);
      pop();
      pop();
    }

    function drawHandle(p, col) {
      push();
      noStroke();
      fill('#ffffff');
      circle(p.x, p.y, HANDLE_R*2+2);
      stroke(col);
      strokeWeight(2);
      noFill();
      circle(p.x, p.y, HANDLE_R*2);
      pop();
    }

    function parallelogram(aP, bP, sumP) {
      push();
      stroke('#94a3b8');
      strokeWeight(1.5);
      noFill();
      // losange: 0 -> a, 0 -> b, a -> a+b, b -> a+b
      line(origin.x, origin.y, aP.x, aP.y);
      line(origin.x, origin.y, bP.x, bP.y);
      line(aP.x, aP.y, sumP.x, sumP.y);
      line(bP.x, bP.y, sumP.x, sumP.y);
      pop();
    }

    function triangleMethod(aP, bP, sumP) {
      push();
      // tracer βv translaté à la pointe de αu
      stroke(COL_BV);
      strokeWeight(2);
      const au_to_auv = { x: aP.x + (bP.x - origin.x), y: aP.y + (bP.y - origin.y) };
      line(aP.x, aP.y, au_to_auv.x, au_to_auv.y);
      // petite pointe de flèche pour la 2e jambe
      const ang = Math.atan2(au_to_auv.y - aP.y, au_to_auv.x - aP.x);
      push();
      fill(COL_BV);
      translate(au_to_auv.x, au_to_auv.y);
      rotate(ang);
      beginShape();
      vertex(0,0);
      vertex(-10, 6);
      vertex(-10,-6);
      endShape(CLOSE);
      pop();

      // segment de fermeture (pointillé) pour clarté
      stroke('#cbd5e1');
      drawingContext.setLineDash([6,6]);
      line(origin.x, origin.y, aP.x, aP.y);
      drawingContext.setLineDash([]);
      pop();
    }

    function updateMath() {
      const mathDiv = document.getElementById('math');
      const ux = u.x, uy = u.y, vx = v.x, vy = v.y;
      const au = { x: alpha*ux, y: alpha*uy };
      const bv = { x: beta*vx, y: beta*vy };
      const r = { x: au.x + bv.x, y: au.y + bv.y };

      mathDiv.innerHTML = `
      $$\\mathbf u = \\begin{pmatrix} ${fmt(ux)} \\\\ ${fmt(uy)} \\end{pmatrix},\\quad
        \\mathbf v = \\begin{pmatrix} ${fmt(vx)} \\\\ ${fmt(vy)} \\end{pmatrix}$$
      $$\\alpha = ${fmt(alpha)},\\;\\beta = ${fmt(beta)}$$
      $$\\alpha\\mathbf u = \\begin{pmatrix} ${fmt(au.x)} \\\\ ${fmt(au.y)} \\end{pmatrix},\\quad
        \\beta\\mathbf v = \\begin{pmatrix} ${fmt(bv.x)} \\\\ ${fmt(bv.y)} \\end{pmatrix}$$
      $$\\mathbf r = \\alpha\\mathbf u + \\beta\\mathbf v
        = \\begin{pmatrix} ${fmt(r.x)} \\\\ ${fmt(r.y)} \\end{pmatrix}$$
      `;
      if (window.MathJax && MathJax.typesetPromise) {
        MathJax.typesetPromise([mathDiv]).catch(() => {});
      }
    }

    function scheduleTypeset() {
      needsTypeset = true;
    }

    // ---------- p5.js ----------
    function setup() {
      const cnv = createCanvas(WIDTH, HEIGHT);
      cnv.parent('container');
      pixelDensity(1);
      textFont('system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif');
      origin = { x: WIDTH/2, y: HEIGHT/2 };

      // UI refs
      ui.alpha = document.getElementById('alpha');
      ui.beta = document.getElementById('beta');
      ui.alphaVal = document.getElementById('alphaVal');
      ui.betaVal = document.getElementById('betaVal');
      ui.link = document.getElementById('linkScalars');
      ui.showPar = document.getElementById('showParallelogram');
      ui.showTri = document.getElementById('showTriangle');
      ui.showSum = document.getElementById('showSum');
      ui.snap = document.getElementById('snapGrid');
      ui.reset = document.getElementById('resetBtn');
      ui.random = document.getElementById('randomBtn');
      ui.betaRow = document.getElementById('betaRow');

      // Listeners
      ui.alpha.addEventListener('input', e => {
        alpha = parseFloat(e.target.value);
        if (ui.link.checked) {
          beta = alpha;
          ui.beta.value = String(beta);
          ui.betaVal.textContent = fmt(beta);
        }
        ui.alphaVal.textContent = fmt(alpha);
        scheduleTypeset();
      });
      ui.beta.addEventListener('input', e => {
        beta = parseFloat(e.target.value);
        ui.betaVal.textContent = fmt(beta);
        scheduleTypeset();
      });
      ui.link.addEventListener('change', e => {
        link = ui.link.checked;
        if (link) {
          beta = alpha;
          ui.beta.value = String(beta);
          ui.betaVal.textContent = fmt(beta);
          ui.betaRow.style.opacity = 0.5;
          ui.beta.disabled = true;
        } else {
          ui.betaRow.style.opacity = 1;
          ui.beta.disabled = false;
        }
        scheduleTypeset();
      });
      ui.reset.addEventListener('click', () => {
        u = { x: 3, y: 2 };
        v = { x: -2, y: 1.5 };
        alpha = 1; beta = 1;
        ui.alpha.value = '1';
        ui.beta.value = '1';
        ui.alphaVal.textContent = '1.00';
        ui.betaVal.textContent = '1.00';
        ui.link.checked = false;
        ui.beta.disabled = false;
        ui.betaRow.style.opacity = 1;
        scheduleTypeset();
      });
      ui.random.addEventListener('click', () => {
        function rnd() {
          let val = Math.round((Math.random()*8 - 4)); // -4..4
          if (val === 0) val = 1;
          return val;
        }
        u = { x: rnd(), y: rnd() };
        v = { x: rnd(), y: rnd() };
        scheduleTypeset();
      });
      

      scheduleTypeset();
    }

    function draw() {
      drawGrid();

      // Construire vecteurs scalés
      const au = { x: alpha*u.x, y: alpha*u.y };
      const bv = { x: beta*v.x,  y: beta*v.y };
      const r  = { x: au.x + bv.x, y: au.y + bv.y };

      // Points en pixels
      const O  = toCanvas({x:0,y:0});
      const U  = toCanvas(u);
      const V  = toCanvas(v);
      const AU = toCanvas(au);
      const BV = toCanvas(bv);
      const R  = toCanvas(r);

      // Dessins d'aide (parallélogramme / triangle)
      if (ui.showPar && ui.showPar.checked) parallelogram(AU, BV, R);
      if (ui.showTri && ui.showTri.checked) triangleMethod(AU, BV, R);

      // Vecteurs de base u, v
      drawArrow(O, U, COL_U, 3.2, 12);
      drawArrow(O, V, COL_V, 3.2, 12);

      // Vecteurs scalés αu, βv
      drawArrow(O, AU, COL_AU, 3, 10);
      drawArrow(O, BV, COL_BV, 3, 10);

      // Somme r
      if (ui.showSum && ui.showSum.checked) {
        drawArrow(O, R, COL_SUM, 4, 12);
      }

      // Poignées
      drawHandle(U, COL_U);
      drawHandle(V, COL_V);

      // Légende flottante
      noStroke();
      fill('#374151');
      textSize(12);
      textAlign(LEFT, TOP);
      text('Drag: u (bleu) / v (orange) ', 8, 8);

      // Typeset throttling (éviter d’appeler MathJax à chaque frame)
      const now = millis();
      if (needsTypeset && now - lastTypeset > 150) {
        updateMath();
        needsTypeset = false;
        lastTypeset = now;
      }
    }

    function mousePressed() {
      // Détecter clic proche de U ou V
      const U = toCanvas(u);
      const V = toCanvas(v);
      if (dist2(mouseX, mouseY, U.x, U.y) <= (HANDLE_R+4)*(HANDLE_R+4)) dragging = 'u';
      else if (dist2(mouseX, mouseY, V.x, V.y) <= (HANDLE_R+4)*(HANDLE_R+4)) dragging = 'v';
    }

    function mouseDragged() {
      if (!dragging) return;
      // Limiter au canvas
      if (mouseX < 0 || mouseX > WIDTH || mouseY < 0 || mouseY > HEIGHT) return;

      let p = fromCanvas(mouseX, mouseY);
      // Aimantation si checkbox ON ou si Shift enfoncé
      const snap = (ui.snap && ui.snap.checked) || keyIsDown(SHIFT);
      if (snap) {
        // pas de 0.5 unité pour un contrôle fin
        p.x = Math.round(p.x*2)/2;
        p.y = Math.round(p.y*2)/2;
      }
      if (dragging === 'u') u = p;
      if (dragging === 'v') v = p;
      scheduleTypeset();
    }

    function mouseReleased() { dragging = null; }
  </script>
</body>
</html>
