<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pivot de Gauss — Animation</title>
  <style>
    html, body { height: 100%; margin: 0; background: transparent; }
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      background: transparent;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }
    .page { 
      display: flex; 
      flex-direction: column;
      align-items: center; 
      gap: 20px; 
      padding: 16px; 
      background: transparent; 
    }
    .title-container { text-align: center; margin-bottom: 20px; }
    .title-container h1 {
      font-size: 28px;
      font-weight: 700;
      color: #1f2937;
      margin: 0;
      letter-spacing: -0.5px;
    }
    .content { display: flex; align-items: flex-start; gap: 20px; }
    /* Zone dessin p5.js */
    #container {
      position: relative;
      width: 800px;
      height: 626px;
      overflow: hidden;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: transparent;
      box-shadow: 0 6px 18px rgba(0,0,0,0.08);
    }
    /* Panneau latéral */
    #panel {
      width: 300px;
      height: 600px;
      padding: 12px;
      border-radius: 10px;
      background: transparent;
      border: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      overflow: auto;
    }
    #panel h2 { font-size: 18px; margin: 8px 0; }
    #panel .row { display: flex; gap: 8px; align-items: center; margin: 6px 0; }
    #panel label { font-size: 13px; color: #374151; }
    #panel input[type="number"] {
      width: 40px; padding: 4px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;
    }
    #panel button, #panel select {
      padding: 8px 10px; border-radius: 8px; border: 1px solid #ddd; background: white; cursor: pointer;
    }
    #panel button:hover { background: #f7f7f7; }
    #panel .btns { display: flex; flex-wrap: wrap; gap: 8px; margin: 8px 0; }
    #panel .small { font-size: 12px; color: #6b7280; }
    #panel .formula { font-size: 14px; color: #111827; background: rgba(0,0,0,0.03); padding: 8px; border-radius: 8px; }
    #panel .sep { height: 1px; background: #eee; margin: 10px 0; }
    .toggle { display: flex; gap: 6px; align-items: center; }
  </style>

  <!-- MathJax pour les formules -->
  <script>
    window.MathJax = {
      tex: { inlineMath: [['$', '$']], displayMath: [['$$', '$$']] }
    };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

  <!-- p5.js -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>
</head>
<body>
  <div class="page">
    <div class="title-container">
      <h1>Animation du pivot de Gauss</h1>
    </div>
    <div class="content">
      <div id="container"></div>
      <div id="panel">
        <h2>Réglages du système</h2>
                 <div class="row">
           <label for="sizeSel">Taille :</label>
           <select id="sizeSel">
             <option value="2">2×2</option>
             <option value="3" selected>3×3</option>
             <option value="4">4×4</option>
           </select>
         </div>
        <div id="matrixInputs"></div>

        <div class="btns">
          <button id="randomBtn">Mélanger</button>
        </div>

        <div class="sep"></div>

        <h2>Animation</h2>
        <div class="btns">
          <!-- <button id="playPauseBtn">Lecture</button> -->
          <button id="resetBtn">Réinitialiser</button>
          <button id="nextBtn">Étape suivante</button>
        </div>
        <!-- <div class="row">
          <label>Vitesse</label>
          <input id="speedRange" type="range" min="0.25" max="2" step="0.25" value="1">
          <span id="speedVal" class="small">1×</span>
        </div> -->

        <!-- <div class="row toggle">
          <input id="scalePivotChk" type="checkbox" unchecked>
          <label for="scalePivotChk">Réduire les pivots à 1 ($R_i\\leftarrow R_i/\\text{pivot}$)</label>
        </div> -->

        <div class="sep"></div>

        <h2>Opération courante</h2>
        <div id="opLatex" class="formula">$\\text{Prêt.}$</div>
        
      </div>
    </div>
  </div>

  <script>
        // ------- État global du modèle -------
          const Model = {
        n: 3,                 // taille (2, 3 ou 4)
        A: [[2,1,-1],[-3,-1,2],[-2,1,2]],
        b: [8,-11,-3],
      original: null,       // sauvegarde pour réinitialiser
      partialPivot: false,
      scalePivotToOne: false,
      steps: [],            // séquence d'opérations
      stepIndex: -1,        // index de l'étape affichée (avant/après)
      playing: false,
      speed: 1.0
    };

    // Sauvegarde initiale
    function snapshotInitial() {
      Model.original = {
        n: Model.n,
        A: Model.A.map(r => r.slice()),
        b: Model.b.slice()
      };
    }
    snapshotInitial();

    // ------- Génération des champs d'édition dans le panneau -------
    function buildInputs() {
      const wrap = document.getElementById('matrixInputs');
      wrap.innerHTML = '';
      const tbl = document.createElement('table');
      tbl.style.borderCollapse = 'collapse';
      const n = Model.n;
      for (let i = 0; i < n; i++) {
        const tr = document.createElement('tr');
        for (let j = 0; j < n; j++) {
          const td = document.createElement('td');
          td.style.padding = '4px';
                     const inp = document.createElement('input');
           inp.type = 'number'; inp.step = '1';
           inp.value = Model.A[i][j];
           inp.addEventListener('change', () => {
             Model.A[i][j] = parseInt(inp.value || '0');
             recomputeStepsAndResetAnim();
           });
          td.appendChild(inp);
          tr.appendChild(td);
        }
        const tdSep = document.createElement('td');
        tdSep.style.padding = '0 6px';
        tdSep.textContent = '|';
        tr.appendChild(tdSep);
        const tdB = document.createElement('td');
        tdB.style.padding = '4px';
                 const inpb = document.createElement('input');
         inpb.type = 'number'; inpb.step = '1';
         inpb.value = Model.b[i];
         inpb.addEventListener('change', () => {
           Model.b[i] = parseInt(inpb.value || '0');
           recomputeStepsAndResetAnim();
         });
        tdB.appendChild(inpb);
        tr.appendChild(tdB);
        tbl.appendChild(tr);
      }
      wrap.appendChild(tbl);
      MathJax.typesetPromise?.();
      
    }

    // ------- Outils algorithmiques -------

    // Copie profonde [A|b]
    function cloneAug(A, b) {
      return { A: A.map(r => r.slice()), b: b.slice() };
    }

    // Appliquer une opération élémentaire sur un état [A|b]
    function applyOp(state, op) {
      const {A,b} = state;
      const n = A.length;
      if (op.type === 'swap') {
        const i = op.i, j = op.j;
        [A[i], A[j]] = [A[j], A[i]];
        [b[i], b[j]] = [b[j], b[i]];
      } else if (op.type === 'scale') {
        const i = op.i, lambda = op.lambda;
        for (let k=0;k<n;k++) A[i][k] *= lambda;
        b[i] *= lambda;
      } else if (op.type === 'elim') {
        const i = op.i, k = op.k, alpha = op.alpha;
        for (let c=0;c<n;c++) A[i][c] += alpha * A[k][c];
        b[i] += alpha * b[k];
      }
    }

    // Calcule la suite d'opérations de Gauss (échelonnée), avec options.
    function computeGaussianSteps(Ain, bin, partialPivot=false, scalePivot=true) {
      const n = Ain.length;
      const state = cloneAug(Ain, bin);
      const steps = [];
      let row = 0, col = 0;
      while (row < n && col < n) {
        // Pivot partiel
        let pivotRow = row;
        
        // Si pivot nul, avancer en colonne
        if (Math.abs(state.A[pivotRow][col]) < 1e-12) {
          col++;
          continue;
        }
        if (pivotRow !== row) {
          steps.push({type:'swap', i: row, j: pivotRow, latex:`$R_{${row+1}}\\leftrightarrow R_{${pivotRow+1}}$`, pivotPos:[row,col]});
          applyOp(state, steps.at(-1));
        }
        // Normaliser le pivot à 1
        const pivot = state.A[row][col];
        if (scalePivot && Math.abs(pivot-1) > 1e-12) {
          const lambda = 1/pivot;
          steps.push({type:'scale', i: row, lambda, latex:`$R_{${row+1}}\\leftarrow \\dfrac{1}{${fmt(pivot)}}\\,R_{${row+1}}$`, pivotPos:[row,col]});
          applyOp(state, steps.at(-1));
        }
        // Élimination sous la ligne pivot
        for (let r = row+1; r < n; r++) {
          if (Math.abs(state.A[r][col])>1e-12) {
            const alpha = - state.A[r][col] / state.A[row][col];
            steps.push({type:'elim', i: r, k: row, alpha, latex:`$R_{${r+1}}\\leftarrow R_{${r+1}} + (${fmt(alpha)})\\,R_{${row+1}}$`, pivotPos:[row,col]});
            applyOp(state, steps.at(-1));
          }
        }
        row++; col++;
      }
      return steps;
    }

    function fmt(x) {
      const s = Math.abs(x) < 1e-12 ? 0 : x;
      const str = (Math.round(s*1000)/1000).toString();
      return str;
    }

    // ------- Animation & rendu p5 -------

    // Paramètres de rendu
    const View = {
      x0: 0,           // sera calculé pour centrer
      y0: 60,          // marge haute
      cellW: 120,
      cellH: 60,
      gap: 20,         // espace avant le séparateur |
      sepW: 10,
      highlightCol: [59,130,246], // bleu
      pivotCol: [16,185,129],     // vert
      opColor: [31,41,55],        // gris foncé
      bgRow: [249,250,251]
    };

    // État visuel interpolé
    const Viz = {
      // état courant visible (matrice) que l’on interpole
      A: null, b: null,
      // positions Y de lignes (pour swap animé)
      yRow: [],
      // animation en cours
      anim: null, // {op, t:[0..1]}
      // instantanés pour interpolation
      from: null, to: null
    };

    function setupVizFromModel() {
      const n = Model.n;
      Viz.A = Model.A.map(r => r.slice());
      Viz.b = Model.b.slice();
      
             // Calculer x0 pour centrer la matrice
       const totalWidth = n * View.cellW + View.gap + View.cellW; // A + gap + b
       View.x0 = (800 - totalWidth) / 2; // 800 est la largeur du canvas
       
       // Ajuster la taille des cellules pour les systèmes 4x4
       if (n === 4) {
         View.cellW = 90;  // Cellules plus petites pour 4x4
         View.cellH = 50;
         // Recalculer x0 avec les nouvelles dimensions
         const newTotalWidth = n * View.cellW + View.gap + View.cellW;
         View.x0 = (800 - newTotalWidth) / 2;
       } else {
         View.cellW = 120; // Taille normale pour 2x2 et 3x3
         View.cellH = 60;
       }
      
      Viz.yRow = Array.from({length:n}, (_,i)=> View.y0 + i*View.cellH);
      Viz.anim = null;
      Viz.from = null; Viz.to = null;
    }

    // Calculer Viz.to à partir d'une op appliquée à Viz.from
    function makeToFromOp(from, op) {
      const n = Model.n;
      const to = {
        A: from.A.map(r=>r.slice()),
        b: from.b.slice(),
        yRow: from.yRow.slice()
      };
      if (op.type === 'swap') {
        const {i,j} = op;
        // Les valeurs ne changent pas immédiatement (on garde), on animera la position
        const yi = to.yRow[i], yj = to.yRow[j];
        to.yRow[i] = yj; to.yRow[j] = yi;
      } else if (op.type === 'scale') {
        const {i, lambda} = op;
        for (let c=0;c<n;c++) to.A[i][c] = from.A[i][c]*lambda;
        to.b[i] = from.b[i]*lambda;
      } else if (op.type === 'elim') {
        const {i,k,alpha} = op;
        for (let c=0;c<n;c++) to.A[i][c] = from.A[i][c] + alpha*from.A[k][c];
        to.b[i] = from.b[i] + alpha*from.b[k];
      }
      return to;
    }

    function lerpArray(a, b, t) {
      return a.map((v,i)=> v + (b[i]-v)*t);
    }
    function lerp2D(A, B, t) {
      return A.map((row,i)=> row.map((v,j)=> v + (B[i][j]-v)*t));
    }

    // Lance l'animation d'une étape
    function startStepAnimation(stepIdx) {
      const op = Model.steps[stepIdx];
      const from = {
        A: Viz.A.map(r=>r.slice()),
        b: Viz.b.slice(),
        yRow: Viz.yRow.slice()
      };
      const to = makeToFromOp(from, op);
      Viz.anim = {op, t:0};
      Viz.from = from; Viz.to = to;
      setLatex(op.latex);
    }

    // Applique instantanément toutes les étapes jusqu’à stepIdx (utile pour "Précédente")
    function snapToStep(stepIdx) {
      setupVizFromModel();
      const state = cloneAug(Model.A, Model.b);
      // on repart de l'original
      let cur = cloneAug(Model.original.A, Model.original.b);
      Viz.A = cur.A.map(r=>r.slice());
      Viz.b = cur.b.slice();
      
             // Recalculer x0 pour centrer
       const totalWidth = Model.n * View.cellW + View.gap + View.cellW;
       View.x0 = (800 - totalWidth) / 2;
       
       // Ajuster la taille des cellules pour les systèmes 4x4
       if (Model.n === 4) {
         View.cellW = 90;  // Cellules plus petites pour 4x4
         View.cellH = 50;
         // Recalculer x0 avec les nouvelles dimensions
         const newTotalWidth = Model.n * View.cellW + View.gap + View.cellW;
         View.x0 = (800 - newTotalWidth) / 2;
       } else {
         View.cellW = 120; // Taille normale pour 2x2 et 3x3
         View.cellH = 60;
       }
      
      Viz.yRow = Array.from({length:Model.n}, (_,i)=> View.y0 + i*View.cellH);
      for (let k=0;k<=stepIdx;k++) {
        const op = Model.steps[k];
        if (!op) break;
        if (op.type === 'swap') {
          // échange visuel immédiat des Y
          const i = op.i, j = op.j;
          const yi = Viz.yRow[i], yj = Viz.yRow[j];
          Viz.yRow[i] = yj; Viz.yRow[j] = yi;
        } else if (op.type === 'scale') {
          const {i,lambda} = op;
          for (let c=0;c<Model.n;c++) Viz.A[i][c] *= lambda;
          Viz.b[i] *= lambda;
        } else if (op.type === 'elim') {
          const {i,k,alpha} = op;
          for (let c=0;c<Model.n;c++) Viz.A[i][c] += alpha*Viz.A[k][c];
          Viz.b[i] += alpha*Viz.b[k];
        }
      }
      setLatex(stepIdx>=0 && Model.steps[stepIdx] ? Model.steps[stepIdx].latex : '$\\text{Prêt.}$');
      Viz.anim = null;
    }

    function setLatex(tex) {
      const el = document.getElementById('opLatex');
      el.innerHTML = tex || '$\\text{Prêt.}$';
      MathJax.typesetPromise?.();
    }

    // ------- p5 Sketch -------
    let sketch = (p) => {
      p.setup = () => {
        const cnv = p.createCanvas(800,600);
        cnv.parent('container');
        setupVizFromModel();
        recomputeStepsAndResetAnim(); // calcule steps et remet au début
      };

      p.draw = () => {
        p.background(255);
        
        // Première copie (originale)
        drawTitleArea(p);
        drawMatrix(p);
        tickAnimation(p);
      };

    };

    function drawTitleArea(p) {
      p.push();
      p.noStroke();
      p.fill(17,24,39);
      p.textAlign(p.LEFT, p.TOP);
      p.textSize(14);
      p.text("Matrice augmentée [A | b] — Pivot de Gauss", 16, 14);
      p.pop();
    }

    function cellRect(r, c, n) {
      const xA = View.x0;
      const y = Viz.yRow[r];
      const x = xA + c*View.cellW;
      return {x, y, w: View.cellW, h: View.cellH};
    }

    function bRect(r, n) {
      const xA = View.x0;
      const y = Viz.yRow[r];
      const xSep = xA + n*View.cellW + View.gap;
      const x = xSep + View.sepW;
      return {x, y, w: View.cellW, h: View.cellH};
    }

    function drawMatrix(p) {
      const n = Model.n;
      // fond
      p.push();
      p.noStroke();
      p.fill(250);
      p.rect(20,40,760,540,10);
      p.pop();

      // lignes alternées
      for (let r=0;r<n;r++) {
        p.noStroke();
        p.fill(245);
        const rowWidth = n * View.cellW + View.gap + View.cellW;
        p.rect(View.x0 - 4, Viz.yRow[r]-2, rowWidth + 8, View.cellH+4, 8);
      }

      // séparateur |
      const xSep = View.x0 + n*View.cellW + View.gap;
      p.stroke(200);
      p.strokeWeight(2);
      p.line(xSep, View.y0-10, xSep, View.y0 + (n-1)*View.cellH + View.cellH + 10);

             // cellules A
       p.textAlign(p.CENTER, p.CENTER);
       p.textSize(Model.n === 4 ? 14 : 18); // Texte plus petit pour 4x4
      for (let r=0;r<n;r++) {
        for (let c=0;c<n;c++) {
          const rect = cellRect(r,c,n);
          p.stroke(230);
          p.noFill();
          p.rect(rect.x, rect.y, rect.w, rect.h, 8);

          p.noStroke();
          p.fill(17,24,39);
          const val = Viz.A[r][c];
          p.text(fmt(val), rect.x + rect.w/2, rect.y + rect.h/2);
        }
      }

      // cellules b
      for (let r=0;r<n;r++) {
        const rect = bRect(r, n);
        p.stroke(230);
        p.noFill();
        p.rect(rect.x, rect.y, rect.w, rect.h, 8);
        p.noStroke();
        p.fill(17,24,39);
        p.text(fmt(Viz.b[r]), rect.x + rect.w/2, rect.y + rect.h/2);
      }

      // surbrillance du pivot courant
      const op = Model.steps[Model.stepIndex+1] || Model.steps[Model.stepIndex];
      const pivotPos = op?.pivotPos;
      if (pivotPos) {
        const [pr, pc] = pivotPos;
        const rect = cellRect(pr, pc, n);
        p.noFill();
        p.stroke(View.pivotCol[0], View.pivotCol[1], View.pivotCol[2]);
        p.strokeWeight(3);
        p.rect(rect.x, rect.y, rect.w, rect.h, 8);
      }

      // Légende
    //   p.push();
    //   p.noStroke();
    //   p.fill(31,41,55);
    //   p.textSize(12);
    //   p.textAlign(p.LEFT, p.TOP);
    //   p.text("Cliquer une cellule pour l’éditer • Étapes générées automatiquement", 24, 520);
    //   p.pop();
      
      // Liste des opérations
      drawOperationsList(p);
    }

    function drawOperationsList(p) {
      p.push();
      p.noStroke();
      p.textAlign(p.CENTER, p.TOP); // Centré
      p.textSize(12);
      
      const startX = 400; // Centre du canvas (800/2)
      const startY = 320;
      const lineHeight = 30; // Encore plus d'espace
      
      // Titre de la section
      p.fill(17,24,39);
      p.textSize(18); // Encore plus gros titre
      p.text("Liste des opérations :", startX, startY);
      
          // Liste des opérations
        p.textSize(22); // Encore plus gros texte pour les opérations
      
        if (Model.steps.length === 0) {
         p.fill(156,163,175); // Gris pour "aucune opération"
         p.text("Aucune opération calculée", startX, startY + lineHeight);
       } else {
         for (let i = 0; i < Model.steps.length; i++) {
           const step = Model.steps[i];
           const y = startY + (i + 1) * lineHeight;
           
           // Description de l'opération avec couleur selon l'état
           if (i < Model.stepIndex) {
             p.fill(75,85,99); // Couleur normale pour les étapes terminées
           } else if (i === Model.stepIndex) {
             p.fill(59,130,246); // Bleu pour l'étape courante
           } else {
             p.fill(156,163,175); // Gris clair pour les étapes à venir
           }
           
           let description = "";
           if (step.type === 'swap') {
             description = `Échange R${step.i+1} ↔ R${step.j+1}`;
           } else if (step.type === 'scale') {
             description = `R${step.i+1} ← ${fmt(step.lambda)} × R${step.i+1}`;
           } else if (step.type === 'elim') {
             description = `R${step.i+1} ← R${step.i+1} + ${fmt(step.alpha)} × R${step.k+1}`;
           }
           
           // Ajouter l'indicateur au début de la description
           let fullDescription = "";
           if (i === Model.stepIndex) {
             fullDescription = "▶ " + description;
           } else if (i < Model.stepIndex) {
             fullDescription = "✓ " + description;
           } else {
             fullDescription = "○ " + description;
           }
           
           p.text(fullDescription, startX, y);
         }
       }
      
      p.pop();
    }

    function pickCell(mx, my) {
      const n = Model.n;
      for (let r=0;r<n;r++) {
        for (let c=0;c<n;c++) {
          const rect = cellRect(r,c,n);
          if (mx>=rect.x && mx<=rect.x+rect.w && my>=rect.y && my<=rect.y+rect.h) {
            return {r, c, isB:false};
          }
        }
        const rectB = bRect(r,n);
        if (mx>=rectB.x && mx<=rectB.x+rectB.w && my>=rectB.y && my<=rectB.y+rectB.h) {
          return {r, c:null, isB:true};
        }
      }
      return null;
    }

    function tickAnimation(p) {
      const anim = Viz.anim;
      if (!anim) {
        if (Model.playing) advanceIfPossible();
        return;
      }
      const dt = p.deltaTime / 1000 * Model.speed;
      anim.t += dt / 0.6; // durée “normale” 0.6 s, modulée par speed
      const t = Math.min(anim.t, 1);

      // Interpolation
      if (anim.op.type === 'swap') {
        Viz.yRow = lerpArray(Viz.from.yRow, Viz.to.yRow, easeInOut(t));
        // Valeurs inchangées
        Viz.A = Viz.from.A.map(r=>r.slice());
        Viz.b = Viz.from.b.slice();
      } else {
        // positions fixes
        Viz.yRow = Viz.from.yRow.slice();
        // interpolation des valeurs
        Viz.A = lerp2D(Viz.from.A, Viz.to.A, easeInOut(t));
        Viz.b = lerpArray(Viz.from.b, Viz.to.b, easeInOut(t));
      }

      if (t>=1) {
        // Fin d’animation -> fixer l'état cible
        Viz.A = Viz.to.A.map(r=>r.slice());
        Viz.b = Viz.to.b.slice();
        Viz.yRow = Viz.to.yRow.slice();
        Viz.anim = null;
        Model.stepIndex++;
        if (Model.playing) advanceIfPossible();
      }
    }

    function easeInOut(t) {
      return t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
    }

    function advanceIfPossible() {
      const next = Model.stepIndex + 1;
      if (next < Model.steps.length) {
        startStepAnimation(next);
      } else {
        Model.playing = false;
        setLatex('$\\text{Terminé. Matrice échelonnée obtenue.}$');
      }
    }

    function goPrev() {
      if (Viz.anim) { // annuler anim en cours
        Viz.anim = null;
      }
      const prev = Model.stepIndex - 1;
      Model.stepIndex = prev;
      snapToStep(prev);
    }

    // ------- (Re)calcul des étapes -------
    function recomputeStepsAndResetAnim() {
      // remettre l'original = état courant
      Model.original = { n: Model.n, A: Model.A.map(r=>r.slice()), b: Model.b.slice() };
      Model.steps = computeGaussianSteps(Model.A, Model.b, Model.partialPivot, Model.scalePivotToOne);
      Model.stepIndex = -1;
      setupVizFromModel();
      setLatex('$\\text{Prêt.}$');
      
      // Désactiver le bouton reset quand on recalcule
      const resetBtn = document.getElementById('resetBtn');
      resetBtn.disabled = true;
      resetBtn.style.opacity = '0.5';
      resetBtn.style.cursor = 'not-allowed';
    }

    // ------- UI / événements -------
    function randomizeSystem() {
      const n = Model.n;
      function rnd() { return Math.floor(Math.random()*10)-5; } // -3..3 entiers
      for (let i=0;i<n;i++) {
        for (let j=0;j<n;j++) {
          Model.A[i][j] = (i===j ? rnd()+1 : rnd()); // diagonale pas trop petite
        }
        Model.b[i] = rnd()*2; // valeurs entières pour b
      }
      buildInputs();
      recomputeStepsAndResetAnim();
    }

    function resetSystem() {
      Model.n = Model.original.n;
      Model.A = Model.original.A.map(r=>r.slice());
      Model.b = Model.original.b.slice();
      buildInputs();
      recomputeStepsAndResetAnim();
      
      // Réactiver le bouton reset après utilisation
      const resetBtn = document.getElementById('resetBtn');
      resetBtn.disabled = true;
      resetBtn.style.opacity = '0.5';
      resetBtn.style.cursor = 'not-allowed';
    }

    // Installer contrôles DOM après chargement
    window.addEventListener('DOMContentLoaded', () => {
        
      // Sélecteur taille
      const sizeSel = document.getElementById('sizeSel');
      sizeSel.value = String(Model.n);
      sizeSel.addEventListener('change', () => {
        const n = parseInt(sizeSel.value,10);
        Model.n = n;
        // redimensionner A,b en conservant au mieux
        const Anew = Array.from({length:n}, (_,i)=> Array.from({length:n},(_,j)=> (Model.A[i]?.[j] ?? (i===j?1:0))));
        const bnew = Array.from({length:n}, (_,i)=> (Model.b[i] ?? 0));
        Model.A = Anew; Model.b = bnew;
        buildInputs();
        recomputeStepsAndResetAnim();
      });

      // Boutons
      document.getElementById('randomBtn').addEventListener('click', randomizeSystem);
      document.getElementById('resetBtn').addEventListener('click', resetSystem);

      // Désactiver le bouton reset au début
      const resetBtn = document.getElementById('resetBtn');
      resetBtn.disabled = true;
      resetBtn.style.opacity = '0.5';
      resetBtn.style.cursor = 'not-allowed';

      const playPauseBtn = document.getElementById('playPauseBtn');
    //   playPauseBtn.addEventListener('click', () => {
    //     if (Model.playing) {
    //       Model.playing = false; playPauseBtn.textContent = 'Lecture';
    //     } else {
    //       Model.playing = true; playPauseBtn.textContent = 'Pause';
    //       if (!Viz.anim) advanceIfPossible();
    //     }
    //   });
      document.getElementById('nextBtn').addEventListener('click', () => {
        const nextBtn = document.getElementById('nextBtn');
        const resetBtn = document.getElementById('resetBtn');
        nextBtn.disabled = false;
        nextBtn.style.opacity = '1';
        nextBtn.style.cursor = 'pointer';

        Model.playing = false; 
        // playPauseBtn.textContent = 'Lecture';
        if (Viz.anim) { Viz.anim.t = 1; return; } // terminez l'étape en cours
        const next = Model.stepIndex + 1;
        if (next < Model.steps.length) {
          startStepAnimation(next);
          // Réactiver le bouton reset quand on avance d'une étape
          resetBtn.disabled = false;
          resetBtn.style.opacity = '1';
          resetBtn.style.cursor = 'pointer';
        }
        else {
          nextBtn.disabled = true;
          nextBtn.style.opacity = '0.5';
          nextBtn.style.cursor = 'not-allowed';
        }
      });
    //   document.getElementById('prevBtn').addEventListener('click', () => {
    //     Model.playing = false; 
    //     // playPauseBtn.textContent = 'Lecture';
    //     goPrev();
    //   });

    //   const speedRange = document.getElementById('speedRange');
    //   const speedVal = document.getElementById('speedVal');
    //   speedRange.addEventListener('input', () => {
    //     Model.speed = parseFloat(speedRange.value);
    //     speedVal.textContent = Model.speed.toFixed(2).replace('.00','') + '×';
    //   });


    //   const scalePivotChk = document.getElementById('scalePivotChk');
    //   scalePivotChk.checked = Model.scalePivotToOne;
    //   scalePivotChk.addEventListener('change', () => {
    //     Model.scalePivotToOne = scalePivotChk.checked;
    //     recomputeStepsAndResetAnim();
    //   });

      buildInputs();
      // Démarrer p5
      new p5(sketch);
    });
  </script>
</body>
</html>
