<!DOCTYPE html>
<html>
<head>
    <title>Menu Automatique - Algèbre Linéaire</title>
    <meta charset="utf-8">
</head>
<body>
    <div id="menu-container"></div>

    <script>

        // Configuration des sections principales avec leurs descriptions
        const sectionConfig = {
            '0-Revisions': { title: 'Révisions', description: 'Vecteurs · Pivot de Gauss · Systèmes linéaires' },
            '1-EspacesVectoriels': { title: 'Espaces vectoriels', description: 'Definition · Exemples' },
            '2-FamillesDeVecteurs': { title: 'Familles de vecteurs', description: 'Familles Libres, génératrices · Bases · Dimension' },
            '3-ApplicationsLineaires': { title: 'Applications linéaires', description: 'Definition · Noyau et image · Matrices' },
            '4-Matrices': { title: 'Matrices', description: 'Déterminants · Polynômes de matrices' }
        };

        // Fonction pour extraire le numéro et le titre d'un nom de dossier
        function parseFolderName(folderName) {
            const match = folderName.match(/^(\d+)-(.+)$/);
            if (match) {
                return {
                    number: match[1],
                    title: match[2].replace(/([A-Z])/g, ' $1').trim()
                };
            }
            return { number: '0', title: folderName };
        }

        // Fonction pour détecter les sous-dossiers d'une section
        async function scanSubSections(sectionPath) {
            const subSections = [];
            const sectionNumber = sectionPath.split('-')[0];
            
            // Liste des sous-dossiers connus pour chaque section
            const knownSubSections = {
                '0-Revisions': ['1-Vecteurs', '2-PivotDeGauss', '3-Visualisation'],
                '1-EspacesVectoriels': ['1-LesEnsembles', '2-Definition', '3-SousEspacesVectoriels', '4-Bestiaire'],
                '2-FamillesDeVecteurs': ['1-Coordonnees', '2-CombinaisonsLineaires', '3-LibresGeneratrices', '4-Bases', '5-MatricesDePassage'],
                '3-ApplicationsLineaires': ['1-Definition', '2-Proprietes', '3-TheoremeDuRang', '4-RevisionsMatrices', '5-MatriceDuneApplicationLineaire'],
                '4-Matrices': ['Déterminants', 'PolynomesDeMatrices']
            };

            const subFolders = knownSubSections[sectionPath] || [];
            
            for (const subFolder of subFolders) {
                try {
                    // Essayer d'accéder au fichier index.html dans le sous-dossier
                    const response = await fetch(`${sectionPath}/${subFolder}/index.html`);
                    if (response.ok) {
                        const parsed = parseFolderName(subFolder);
                        subSections.push({
                            path: subFolder,
                            number: `${sectionNumber}.${parsed.number}`,
                            title: parsed.title
                        });
                    }
                } catch (e) {
                    console.log(`Dossier non trouvé: ${sectionPath}/${subFolder}`);
                }
            }
            
            return subSections;
        }

        // Fonction pour générer le SVG complet
        async function generateSVG() {
            let svg = `
<svg viewBox="0 0 1200 700" style="max-width:100%;height:auto" role="group" aria-label="Menu des sections avec panneaux de séquences">
  <style>
    .card { fill:#fff; stroke:#CBD5E1; stroke-width:2; rx:16; }
    .card:hover { filter:url(#shadow); }
    .label { font:600 24px system-ui,Segoe UI,Roboto,sans-serif; fill:#0F172A; }
    .sublabel { font:400 16px system-ui,Segoe UI,Roboto,sans-serif; fill:#475569; }
    .overlay { visibility:hidden; opacity:0; pointer-events:none; transition:opacity .2s ease; }
    .overlay:target { visibility:visible; opacity:1; pointer-events:auto; }
    .backdrop { fill:#0f172a; fill-opacity:.4; }
    .panel { fill:#ffffff; stroke:#94A3B8; stroke-width:2; rx:18; }
    .btn { fill:#F1F5F9; stroke:#CBD5E1; stroke-width:1; rx:12; }
    .btn:hover, a:focus .btn { stroke:#2563EB; }
    .btn-text { font:600 18px system-ui; fill:#0F172A; }
    a:focus .card { stroke:#2563EB; }
    a:focus .label { text-decoration:underline; }
  </style>

  <defs>
    <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="0" dy="4" stdDeviation="6" flood-opacity="0.18"/>
    </filter>
  </defs>`;

            // Générer les cartes principales
            const sections = Object.keys(sectionConfig);
            sections.forEach((sectionPath, index) => {
                const section = sectionConfig[sectionPath];
                const x = (index % 2) * 580 + 60;
                const y = Math.floor(index / 2) * 180 + 60;
                
                svg += `
  <a xlink:href="#sec${index + 1}" role="link" aria-label="Ouvrir ${section.title}">
    <g tabindex="0">
      <rect class="card" x="${x}" y="${y}" width="500" height="140"/>
      <text class="label" x="${x + 30}" y="${y + 50}">Section ${index} · ${section.title}</text>
      <text class="sublabel" x="${x + 30}" y="${y + 85}">${section.description}</text>
    </g>
  </a>`;
            });

            // Générer les overlays pour chaque section
            for (let i = 0; i < sections.length; i++) {
                const sectionPath = sections[i];
                const section = sectionConfig[sectionPath];
                const subSections = await scanSubSections(sectionPath);
                
                svg += generateOverlay(section, i, subSections);
            }

            svg += '</svg>';
            return svg;
        }

        // Fonction pour générer un overlay
        function generateOverlay(section, sectionIndex, subSections) {
            let overlay = `
  <g id="sec${sectionIndex + 1}" class="overlay" role="dialog" aria-label="Séquences Section ${sectionIndex + 1}">
    <a xlink:href="#" aria-label="Fermer le panneau">
      <rect class="backdrop" x="0" y="0" width="1200" height="700"/>
    </a>
    <g transform="translate(150,140)">
      <rect class="panel" x="0" y="0" width="900" height="420"/>
      <text class="label" x="32" y="56">Section ${sectionIndex} · ${section.title} — Séquences</text>
      
      <a xlink:href="#" aria-label="Fermer">
        <g transform="translate(820,20)" tabindex="0">
          <rect class="btn" x="0" y="0" width="64" height="36" rx="10"/>
          <text class="btn-text" x="22" y="24">×</text>
        </g>
      </a>`;

            // Générer les boutons pour chaque sous-section
            subSections.forEach((subSection, subIndex) => {
                const x = (subIndex % 2) * 436 + 32;
                const y = Math.floor(subIndex / 2) * 76 + 96;
                
                overlay += `
      <a xlink:href="${Object.keys(sectionConfig)[sectionIndex]}/${subSection.path}/index.html" target="_blank">
        <g transform="translate(${x},${y})" tabindex="0">
          <rect class="btn" x="0" y="0" width="400" height="56"/>
          <text class="btn-text" x="16" y="36">${subSection.number} · ${subSection.title}</text>
        </g>
      </a>`;
            });

            overlay += `
    </g>
  </g>`;
            
            return overlay;
        }

        // Fonction d'initialisation
        async function init() {
            try {
                const svgContent = await generateSVG();
                document.getElementById('menu-container').innerHTML = svgContent;
                console.log('Menu généré automatiquement avec succès !');
            } catch (error) {
                console.error('Erreur lors de la génération du menu:', error);
                document.getElementById('menu-container').innerHTML = '<p>Erreur lors de la génération du menu</p>';
            }
        }

        // Lancer la génération quand la page est chargée
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>