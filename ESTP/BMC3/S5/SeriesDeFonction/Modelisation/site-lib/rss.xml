<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>obsidian</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 21 Jan 2026 12:33:17 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 21 Jan 2026 12:33:17 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[TP - Modélisation de l'évolution de populations]]></title><description><![CDATA[Le but de ce projet est de modéliser l'évolution dans le temps d'une population (ou plusieurs) interagissant avec son environnement. Ces modèles permettent notamment de comprendre :
L'évolution d'une maladie dans une population (épidémiologie)
L'interaction existant entre les proies et les prédateurs dans le monde animal
La dynamique de croissance des bactéries en laboratoire
Mots clés : simulation, équations différentielles ordinaires, suites, Python, visualisation.Cette section vous présente les outils Python dont vous aurez besoin pour ce TP. Nous utiliserons trois bibliothèques principales :
NumPy : pour les calculs numériques et les tableaux
Matplotlib : pour tracer des graphiques
SciPy : pour résoudre des équations différentielles
# Importation des bibliothèques nécessaires
import numpy as np # Calculs numériques
import matplotlib.pyplot as plt # Tracé de graphiques
from scipy.integrate import odeint # Résolution d'équations différentielles
NumPy permet de créer des tableaux de valeurs très facilement :# Créer un tableau de 100 valeurs entre 0 et 10
t = np.linspace(0, 10, 100)
print(t) # Créer un tableau de 0 à 9 avec un pas de 1
indices = np.arange(0, 10, 1)
print(indices) # Opérations sur les tableaux
y = 2 * t + 1 # Applique l'opération à chaque élément
print(y) Questions :
Q1. Quelle est la différence entre np.linspace(0, 10, 5) et np.arange(0, 10, 5) ? Donnez le résultat de chaque commande.
Q2. On définit t = np.linspace(0, 1, 11). Combien d'éléments contient le tableau t ? Quelle est la valeur de t[0] et t[10] ?
Q3. Si x = np.array([1, 2, 3, 4]), que retourne x**2 + 1 ?
Q4. Quelle commande permet de créer un tableau de 20 zéros ?
# Données
x = np.linspace(0, 10, 100)
y = np.sin(x) # Création du graphique
plt.figure(figsize=(10, 6)) # Taille de la figure
plt.plot(x, y, label='sin(x)', color='blue', linewidth=2)
plt.xlabel('x') # Légende axe x
plt.ylabel('y') # Légende axe y
plt.title('Ma première courbe')
plt.legend() # Affiche la légende
plt.grid(True) # Affiche une grille
plt.show() Exercices : En vous inspirant de l'exemple ci-dessus, tracez les fonctions suivantes :
Exercice 1. sur l'intervalle Exercice 2. sur l'intervalle (utiliser np.exp())
Exercice 3. sur l'intervalle (utiliser np.log())
x = np.linspace(0, 2*np.pi, 100)
y1 = np.sin(x)
y2 = np.cos(x) plt.figure(figsize=(10, 6))
plt.plot(x, y1, label='sin(x)', color='blue')
plt.plot(x, y2, label='cos(x)', color='red', linestyle='--')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Sinus et Cosinus')
plt.legend()
plt.grid(True)
plt.show() Exercice 4. Tracez sur un même graphique les fonctions , et pour , avec une légende et des couleurs différentes.
# Définition d'une fonction simple
def ma_fonction(x): return x**2 + 2*x + 1 # Utilisation
resultat = ma_fonction(3)
print(resultat) # Affiche 16 # Application sur un tableau NumPy
x = np.linspace(-5, 5, 100)
y = ma_fonction(x)
plt.plot(x, y)
plt.show() Questions :
Q5. Écrivez une fonction Python cube(x) qui retourne le cube de x.
Q6. Définissez une fonction polynome(x) qui calcule et tracez-la sur .
# Calcul des termes d'une suite
n_termes = 50
u = np.zeros(n_termes) # Crée un tableau de zéros
u[0] = 1 # Premier terme for n in range(n_termes - 1): u[n+1] = 0.5 * u[n] + 1 # Relation de récurrence # Affichage
plt.figure(figsize=(10, 6))
plt.plot(range(n_termes), u, 'o-', markersize=4)
plt.xlabel('n')
plt.ylabel('u_n')
plt.title('Évolution de la suite')
plt.grid(True)
plt.show() Questions :
Q7. Pourquoi utilise-t-on range(n_termes - 1) et non range(n_termes) dans la boucle ?
Q8. Quelle est la différence entre range(5) et range(1, 6) ?
Q9. Que fait np.zeros(n_termes) ?
Exercice 5. Une suite est définie par et . Écrivez le code pour calculer et afficher les 15 premiers termes.
Pour résoudre une équation différentielle , on utilise odeint :from scipy.integrate import odeint # Exemple : y' = -2*y avec y(0) = 1
def equation(y, t): return -2 * y # Conditions initiales et temps
y0 = 1
t = np.linspace(0, 5, 100) # Résolution
solution = odeint(equation, y0, t) # Tracé
plt.plot(t, solution, label='Solution numérique')
plt.plot(t, np.exp(-2*t), '--', label='Solution exacte')
plt.legend()
plt.show()
]]></description><link>tp-modélisation-de-l'évolution-de-populations.html</link><guid isPermaLink="false">Maths/Bachelor/S5/TP - Modélisation de l'évolution de populations.md</guid><pubDate>Tue, 20 Jan 2026 18:25:03 GMT</pubDate></item></channel></rss>